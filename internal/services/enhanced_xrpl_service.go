package services

import (
	"fmt"
	"log"
	"strconv"
	"time"

	"github.com/smart-payment-infrastructure/internal/models"
	"github.com/smart-payment-infrastructure/pkg/xrpl"
)

// EnhancedXRPLService provides enhanced XRPL functionality using the real XRPL client
type EnhancedXRPLService struct {
	client      *xrpl.EnhancedClient
	initialized bool
}

// Verify that EnhancedXRPLService implements repository.XRPLServiceInterface
// Note: We implement the interface but with enhanced method signatures for real XRPL integration
// var _ repository.XRPLServiceInterface = (*EnhancedXRPLService)(nil)

// NewEnhancedXRPLService creates a new enhanced XRPL service
func NewEnhancedXRPLService(config XRPLConfig) *EnhancedXRPLService {
	client := xrpl.NewEnhancedClient(config.NetworkURL, config.TestNet)
	return &EnhancedXRPLService{
		client: client,
	}
}

// Initialize initializes the enhanced XRPL service
func (s *EnhancedXRPLService) Initialize() error {
	if err := s.client.Connect(); err != nil {
		return fmt.Errorf("failed to connect to XRPL: %w", err)
	}

	if err := s.client.HealthCheck(); err != nil {
		return fmt.Errorf("XRPL health check failed: %w", err)
	}

	s.initialized = true
	log.Println("Enhanced XRPL service initialized successfully")
	return nil
}

// CreateWallet creates a new XRPL wallet using Ed25519 (recommended)
func (s *EnhancedXRPLService) CreateWallet() (*xrpl.WalletInfo, error) {
	if !s.initialized {
		return nil, fmt.Errorf("service not initialized")
	}

	wallet, err := s.client.GenerateWallet()
	if err != nil {
		return nil, fmt.Errorf("failed to create wallet: %w", err)
	}

	log.Printf("Created new XRPL wallet: %s", wallet.Address)
	return wallet, nil
}

// CreateAccount creates a new XRPL account and funds it using the testnet faucet
func (s *EnhancedXRPLService) CreateAccount() (*xrpl.WalletInfo, error) {
	if !s.initialized {
		return nil, fmt.Errorf("service not initialized")
	}

	wallet, err := s.client.CreateAccount()
	if err != nil {
		return nil, fmt.Errorf("failed to create account: %w", err)
	}

	log.Printf("Created new XRPL account: %s", wallet.Address)
	return wallet, nil
}

// CreateSecp256k1Wallet creates a new XRPL wallet using secp256k1
func (s *EnhancedXRPLService) CreateSecp256k1Wallet() (*xrpl.WalletInfo, error) {
	if !s.initialized {
		return nil, fmt.Errorf("service not initialized")
	}

	wallet, err := s.client.GenerateSecp256k1Wallet()
	if err != nil {
		return nil, fmt.Errorf("failed to create secp256k1 wallet: %w", err)
	}

	log.Printf("Created new XRPL secp256k1 wallet: %s", wallet.Address)
	return wallet, nil
}

// ValidateAddress validates an XRPL address
func (s *EnhancedXRPLService) ValidateAddress(address string) bool {
	return s.client.ValidateAddress(address)
}

// ValidateGeneratedAddress validates an address generated by our system
func (s *EnhancedXRPLService) ValidateGeneratedAddress(address string) bool {
	return s.client.ValidateGeneratedAddress(address)
}

// GetAccountInfo retrieves account information from XRPL
func (s *EnhancedXRPLService) GetAccountInfo(address string) (interface{}, error) {
	if !s.initialized {
		return nil, fmt.Errorf("service not initialized")
	}

	accountInfo, err := s.client.GetAccountInfo(address)
	if err != nil {
		return nil, fmt.Errorf("failed to get account info for %s: %w", address, err)
	}

	return accountInfo, nil
}

// GetAccountData retrieves structured account data from XRPL
func (s *EnhancedXRPLService) GetAccountData(address string) (*xrpl.AccountData, error) {
	if !s.initialized {
		return nil, fmt.Errorf("service not initialized")
	}

	accountData, err := s.client.GetAccountData(address)
	if err != nil {
		return nil, fmt.Errorf("failed to get account data for %s: %w", address, err)
	}

	return accountData, nil
}

// GetAccountBalance retrieves account balance from XRPL
func (s *EnhancedXRPLService) GetAccountBalance(address string) (string, error) {
	if !s.initialized {
		return "", fmt.Errorf("service not initialized")
	}

	balance, err := s.client.GetAccountBalance(address)
	if err != nil {
		return "", fmt.Errorf("failed to get account balance for %s: %w", address, err)
	}

	return balance, nil
}

// ValidateAccountOnNetwork validates an XRPL address by checking if the account exists on the network
func (s *EnhancedXRPLService) ValidateAccountOnNetwork(address string) (bool, error) {
	if !s.initialized {
		return false, fmt.Errorf("service not initialized")
	}

	exists, err := s.client.ValidateAccountOnNetwork(address)
	if err != nil {
		return false, fmt.Errorf("failed to validate account on network for %s: %w", address, err)
	}

	return exists, nil
}

// ValidateAccountWithBalance validates an XRPL address and checks if it has sufficient balance
func (s *EnhancedXRPLService) ValidateAccountWithBalance(address string, minBalanceDrops int64) (bool, error) {
	if !s.initialized {
		return false, fmt.Errorf("service not initialized")
	}

	valid, err := s.client.ValidateAccountWithBalance(address, minBalanceDrops)
	if err != nil {
		return false, fmt.Errorf("failed to validate account with balance for %s: %w", address, err)
	}

	return valid, nil
}

// HealthCheck performs health check on the XRPL service
func (s *EnhancedXRPLService) HealthCheck() error {
	if !s.initialized {
		return fmt.Errorf("XRPL service not initialized")
	}
	return s.client.HealthCheck()
}

// CreateSmartChequeEscrow creates an escrow for a Smart Check with enhanced milestone support
func (s *EnhancedXRPLService) CreateSmartChequeEscrow(payerAddress, payeeAddress string, amount float64, currency string, milestoneSecret string, privateKeyHex string) (*xrpl.TransactionResult, string, error) {
	if !s.initialized {
		return nil, "", fmt.Errorf("XRPL service not initialized")
	}

	if privateKeyHex == "" {
		return nil, "", fmt.Errorf("private key is required for escrow creation")
	}
	// Validate payer account has sufficient balance to cover the escrow amount plus base reserve
	minBalanceDrops := int64(amount * 1000000) // Convert XRP to drops (1 XRP = 1,000,000 drops)
	const baseReserveDrops int64 = 10000000    // 10 XRP base reserve (can be configured)
	requiredDrops := minBalanceDrops + baseReserveDrops

	hasBalance, err := s.client.ValidateAccountWithBalance(payerAddress, requiredDrops)
	if err != nil {
		return nil, "", fmt.Errorf("failed to validate payer balance: %w", err)
	}
	if !hasBalance {
		return nil, "", fmt.Errorf("insufficient balance for escrow creation: need %d drops", requiredDrops)
	}
	// Convert amount to appropriate format for XRPL
	amountStr := s.client.FormatAmount(amount, currency)

	// Generate condition and fulfillment for milestone completion
	condition, fulfillment, err := s.client.GenerateCondition(milestoneSecret)
	if err != nil {
		return nil, "", fmt.Errorf("failed to generate escrow condition: %w", err)
	}

	// Set escrow parameters
	escrow := &xrpl.EscrowCreate{
		Account:     payerAddress,
		Destination: payeeAddress,
		Amount:      amountStr,
		Condition:   condition,
		// Set cancel after 30 days (approximate ledger time)
		CancelAfter: s.client.GetLedgerTimeOffset(30 * 24 * time.Hour),
	}

	// Create escrow on XRPL with real transaction signing and submission
	result, err := s.client.CreateEscrow(escrow, privateKeyHex)
	if err != nil {
		return nil, "", fmt.Errorf("failed to create escrow on XRPL testnet: %w", err)
	}

	log.Printf("Created Smart Cheque escrow on XRPL testnet: %s -> %s, Amount: %s, TxID: %s",
		payerAddress, payeeAddress, amountStr, result.TransactionID)

	return result, fulfillment, nil
}

// CreateSmartChequeEscrowWithMilestones creates an escrow with multiple milestones
func (s *EnhancedXRPLService) CreateSmartChequeEscrowWithMilestones(payerAddress, payeeAddress string, amount float64, currency string, milestones []models.Milestone) (*xrpl.TransactionResult, string, error) {
	// For now, use the single milestone implementation
	// In production, this would create a more complex escrow structure
	milestoneSecret := fmt.Sprintf("milestone_%d_%s", time.Now().Unix(), payeeAddress)
	// Note: This method doesn't have private key parameter - would need to be updated for real XRPL integration
	return s.CreateSmartChequeEscrow(payerAddress, payeeAddress, amount, currency, milestoneSecret, "")
}

// CompleteSmartChequeMilestone completes a milestone in a Smart Cheque escrow
func (s *EnhancedXRPLService) CompleteSmartChequeMilestone(payeeAddress, ownerAddress string, sequence uint32, condition, fulfillment string, privateKeyHex string) (*xrpl.TransactionResult, error) {
	if !s.initialized {
		return nil, fmt.Errorf("XRPL service not initialized")
	}

	if privateKeyHex == "" {
		return nil, fmt.Errorf("private key is required for milestone completion")
	}

	// Set escrow finish parameters
	escrowFinish := &xrpl.EscrowFinish{
		Account:       payeeAddress,
		Owner:         ownerAddress,
		OfferSequence: sequence,
		Condition:     condition,
		Fulfillment:   fulfillment,
	}

	// Finish escrow on XRPL with real transaction signing and submission
	result, err := s.client.FinishEscrow(escrowFinish, privateKeyHex)
	if err != nil {
		return nil, fmt.Errorf("failed to finish escrow on XRPL testnet: %w", err)
	}

	log.Printf("Completed Smart Cheque milestone on XRPL testnet: Account: %s, Owner: %s, Sequence: %d, TxID: %s",
		payeeAddress, ownerAddress, sequence, result.TransactionID)

	return result, nil
}

// CancelSmartCheque cancels a Smart Cheque escrow
func (s *EnhancedXRPLService) CancelSmartCheque(accountAddress, ownerAddress string, sequence uint32, privateKeyHex string) (*xrpl.TransactionResult, error) {
	if !s.initialized {
		return nil, fmt.Errorf("XRPL service not initialized")
	}

	if privateKeyHex == "" {
		return nil, fmt.Errorf("private key is required for escrow cancellation")
	}

	// Set escrow cancel parameters
	escrowCancel := &xrpl.EscrowCancel{
		Account:       accountAddress,
		Owner:         ownerAddress,
		OfferSequence: sequence,
	}

	// Cancel escrow on XRPL with real transaction signing and submission
	result, err := s.client.CancelEscrow(escrowCancel, privateKeyHex)
	if err != nil {
		return nil, fmt.Errorf("failed to cancel escrow on XRPL testnet: %w", err)
	}

	log.Printf("Canceled Smart Cheque escrow on XRPL testnet: Account: %s, Owner: %s, Sequence: %d, TxID: %s",
		accountAddress, ownerAddress, sequence, result.TransactionID)

	return result, nil
}

// CreateSmartChequeEscrowWithKey creates an escrow with real XRPL testnet integration (new interface method)
func (s *EnhancedXRPLService) CreateSmartChequeEscrowWithKey(payerAddress, payeeAddress string, amount float64, currency string, milestoneSecret string, privateKeyHex string) (*xrpl.TransactionResult, string, error) {
	return s.CreateSmartChequeEscrow(payerAddress, payeeAddress, amount, currency, milestoneSecret, privateKeyHex)
}

// CompleteSmartChequeMilestoneWithKey completes a milestone with real XRPL testnet integration (new interface method)
func (s *EnhancedXRPLService) CompleteSmartChequeMilestoneWithKey(payeeAddress, ownerAddress string, sequence uint32, condition, fulfillment string, privateKeyHex string) (*xrpl.TransactionResult, error) {
	return s.CompleteSmartChequeMilestone(payeeAddress, ownerAddress, sequence, condition, fulfillment, privateKeyHex)
}

// CancelSmartChequeWithKey cancels a Smart Cheque with real XRPL testnet integration (new interface method)
func (s *EnhancedXRPLService) CancelSmartChequeWithKey(accountAddress, ownerAddress string, sequence uint32, privateKeyHex string) (*xrpl.TransactionResult, error) {
	return s.CancelSmartCheque(accountAddress, ownerAddress, sequence, privateKeyHex)
}

// GetEscrowStatus retrieves escrow status from XRPL
func (s *EnhancedXRPLService) GetEscrowStatus(ownerAddress string, sequence string) (*xrpl.EscrowInfo, error) {
	if !s.initialized {
		return nil, fmt.Errorf("XRPL service not initialized")
	}

	// Use the enhanced client to get real escrow status
	escrowInfo, err := s.client.GetEscrowStatus(ownerAddress, sequence)
	if err != nil {
		return nil, fmt.Errorf("failed to get escrow status: %w", err)
	}

	log.Printf("Retrieved escrow status for owner: %s, sequence: %s", ownerAddress, sequence)
	return escrowInfo, nil
}

// LookupEscrow retrieves detailed escrow information from XRPL ledger
func (s *EnhancedXRPLService) LookupEscrow(ownerAddress string, sequence string) (*xrpl.EscrowInfo, error) {
	if !s.initialized {
		return nil, fmt.Errorf("XRPL service not initialized")
	}

	// Use the enhanced client to lookup escrow details
	escrowInfo, err := s.client.LookupEscrow(ownerAddress, sequence)
	if err != nil {
		return nil, fmt.Errorf("failed to lookup escrow: %w", err)
	}

	log.Printf("Looked up escrow for owner: %s, sequence: %s", ownerAddress, sequence)
	return escrowInfo, nil
}

// VerifyEscrowBalance verifies the locked amount in an escrow
func (s *EnhancedXRPLService) VerifyEscrowBalance(escrowInfo *xrpl.EscrowInfo) (*xrpl.EscrowBalance, error) {
	if !s.initialized {
		return nil, fmt.Errorf("XRPL service not initialized")
	}

	if escrowInfo == nil {
		return nil, fmt.Errorf("escrow info cannot be nil")
	}

	// Use the enhanced client to verify escrow balance
	escrowBalance, err := s.client.VerifyEscrowBalance(escrowInfo)
	if err != nil {
		return nil, fmt.Errorf("failed to verify escrow balance: %w", err)
	}

	log.Printf("Verified escrow balance for escrow: %s_%d", escrowInfo.Account, escrowInfo.Sequence)
	return escrowBalance, nil
}

// GetMultipleEscrows retrieves multiple escrows for an account
func (s *EnhancedXRPLService) GetMultipleEscrows(ownerAddress string, limit int) (*xrpl.EscrowLookupResult, error) {
	if !s.initialized {
		return nil, fmt.Errorf("XRPL service not initialized")
	}

	// Use the enhanced client to get multiple escrows
	result, err := s.client.GetMultipleEscrows(ownerAddress, limit)
	if err != nil {
		return nil, fmt.Errorf("failed to get multiple escrows: %w", err)
	}

	log.Printf("Retrieved %d escrows for owner: %s", result.Total, ownerAddress)
	return result, nil
}

// GetEscrowHistory retrieves escrow transaction history for an account
func (s *EnhancedXRPLService) GetEscrowHistory(ownerAddress string, limit int) ([]xrpl.TransactionResult, error) {
	if !s.initialized {
		return nil, fmt.Errorf("XRPL service not initialized")
	}

	// Use the enhanced client to get escrow history
	transactions, err := s.client.GetEscrowHistory(ownerAddress, limit)
	if err != nil {
		return nil, fmt.Errorf("failed to get escrow history: %w", err)
	}

	log.Printf("Retrieved %d escrow transactions for owner: %s", len(transactions), ownerAddress)
	return transactions, nil
}

// MonitorEscrowStatus continuously monitors escrow status with retry mechanisms
func (s *EnhancedXRPLService) MonitorEscrowStatus(ownerAddress string, sequence string, callback func(*xrpl.EscrowInfo, error)) error {
	if !s.initialized {
		return fmt.Errorf("XRPL service not initialized")
	}

	if callback == nil {
		return fmt.Errorf("callback function cannot be nil")
	}

	// Use the enhanced client to monitor escrow status
	err := s.client.MonitorEscrowStatus(ownerAddress, sequence, callback)
	if err != nil {
		return fmt.Errorf("failed to start escrow monitoring: %w", err)
	}

	log.Printf("Started escrow monitoring for owner: %s, sequence: %s", ownerAddress, sequence)
	return nil
}

// GetEscrowHealthStatus provides comprehensive health status of an escrow
func (s *EnhancedXRPLService) GetEscrowHealthStatus(ownerAddress string, sequence string) (*EscrowHealthStatus, error) {
	if !s.initialized {
		return nil, fmt.Errorf("XRPL service not initialized")
	}

	// Get escrow status
	escrowInfo, err := s.GetEscrowStatus(ownerAddress, sequence)
	if err != nil {
		return nil, fmt.Errorf("failed to get escrow status: %w", err)
	}

	// Verify escrow balance
	escrowBalance, err := s.VerifyEscrowBalance(escrowInfo)
	if err != nil {
		return nil, fmt.Errorf("failed to verify escrow balance: %w", err)
	}

	// Determine escrow health status
	healthStatus := &EscrowHealthStatus{
		SmartChequeID: fmt.Sprintf("%s_%d", ownerAddress, sequence),
		Status:        s.determineEscrowStatus(escrowInfo),
		Health:        s.determineHealthStatus(escrowInfo, escrowBalance),
		Message:       s.generateHealthMessage(escrowInfo, escrowBalance),
		LastSync:      time.Now(),
		EscrowInfo:    escrowInfo,
	}

	log.Printf("Generated escrow health status for escrow: %s", healthStatus.SmartChequeID)
	return healthStatus, nil
}

// determineEscrowStatus determines the current status of an escrow
func (s *EnhancedXRPLService) determineEscrowStatus(escrowInfo *xrpl.EscrowInfo) string {
	if escrowInfo == nil {
		return "unknown"
	}

	// Check flags for escrow status
	if escrowInfo.Flags&0x00010000 != 0 {
		return "expired"
	}
	if escrowInfo.Flags&0x00020000 != 0 {
		return "pending"
	}

	// Check time-based conditions
	currentTime := uint32(time.Now().Unix())
	if escrowInfo.CancelAfter > 0 && currentTime > escrowInfo.CancelAfter {
		return "expired"
	}
	if escrowInfo.FinishAfter > 0 && currentTime < escrowInfo.FinishAfter {
		return "pending"
	}

	return "active"
}

// calculateHealthScore calculates a health score for the escrow (0-100)
func (s *EnhancedXRPLService) calculateHealthScore(escrowInfo *xrpl.EscrowInfo, escrowBalance *xrpl.EscrowBalance) int {
	if escrowInfo == nil || escrowBalance == nil {
		return 0
	}

	score := 100

	// Deduct points for various issues
	if escrowInfo.Flags&0x00010000 != 0 {
		score -= 50 // Expired
	}
	if escrowInfo.Flags&0x00020000 != 0 {
		score -= 20 // Pending
	}

	// Check if balance is properly locked
	if escrowBalance.LockedAmount == "0" {
		score -= 30 // No locked amount
	}

	// Ensure score doesn't go below 0
	if score < 0 {
		score = 0
	}

	return score
}

// generateRecommendations generates recommendations for escrow management
func (s *EnhancedXRPLService) generateRecommendations(escrowInfo *xrpl.EscrowInfo, escrowBalance *xrpl.EscrowBalance) []string {
	var recommendations []string

	if escrowInfo == nil || escrowBalance == nil {
		return []string{"Unable to generate recommendations - insufficient data"}
	}

	// Check for expired escrow
	if escrowInfo.Flags&0x00010000 != 0 {
		recommendations = append(recommendations, "Escrow has expired - consider canceling to recover funds")
	}

	// Check for pending escrow
	if escrowInfo.Flags&0x00020000 != 0 {
		recommendations = append(recommendations, "Escrow is pending - wait for finish time before attempting completion")
	}

	// Check balance
	if escrowBalance.LockedAmount == "0" {
		recommendations = append(recommendations, "No funds locked in escrow - verify escrow creation")
	}

	// Check time conditions
	currentTime := uint32(time.Now().Unix())
	if escrowInfo.CancelAfter > 0 && currentTime > escrowInfo.CancelAfter {
		recommendations = append(recommendations, "Escrow has passed cancel time - funds can be recovered")
	}

	if len(recommendations) == 0 {
		recommendations = append(recommendations, "Escrow is healthy and operating normally")
	}

	return recommendations
}

// determineHealthStatus determines the overall health status of an escrow
func (s *EnhancedXRPLService) determineHealthStatus(escrowInfo *xrpl.EscrowInfo, escrowBalance *xrpl.EscrowBalance) string {
	if escrowInfo == nil || escrowBalance == nil {
		return "unknown"
	}

	// Check for critical issues
	if escrowInfo.Flags&0x00010000 != 0 {
		return "critical" // Expired
	}

	if escrowBalance.LockedAmount == "0" {
		return "warning" // No locked amount
	}

	// Check for minor issues
	if escrowInfo.Flags&0x00020000 != 0 {
		return "pending" // Pending
	}

	// Check time conditions
	currentTime := uint32(time.Now().Unix())
	if escrowInfo.CancelAfter > 0 && currentTime > escrowInfo.CancelAfter {
		return "critical" // Expired
	}

	return "healthy"
}

// generateHealthMessage generates a human-readable health message
func (s *EnhancedXRPLService) generateHealthMessage(escrowInfo *xrpl.EscrowInfo, escrowBalance *xrpl.EscrowBalance) string {
	if escrowInfo == nil || escrowBalance == nil {
		return "Unable to determine escrow health - insufficient data"
	}

	health := s.determineHealthStatus(escrowInfo, escrowBalance)

	switch health {
	case "healthy":
		return "Escrow is operating normally with funds properly locked"
	case "pending":
		return "Escrow is pending and waiting for finish time"
	case "warning":
		return "Escrow has no locked funds - verification required"
	case "critical":
		return "Escrow has expired and requires immediate attention"
	default:
		return "Unknown escrow health status"
	}
}

// GenerateCondition generates escrow condition and fulfillment
func (s *EnhancedXRPLService) GenerateCondition(secret string) (string, string, error) {
	if !s.initialized {
		return "", "", fmt.Errorf("XRPL service not initialized")
	}

	return s.client.GenerateCondition(secret)
}

// CreatePaymentChannel creates a payment channel for streaming payments
func (s *EnhancedXRPLService) CreatePaymentChannel(sourceAddress, destinationAddress string, amount float64, settleDelay uint32) (*xrpl.TransactionResult, error) {
	if !s.initialized {
		return nil, fmt.Errorf("XRPL service not initialized")
	}

	// Convert amount to drops for XRP
	amountStr := s.client.FormatAmount(amount, "XRP")

	// Create payment channel (simplified - in production, use proper XRPL payment channel creation)
	log.Printf("Creating payment channel: %s -> %s, Amount: %s, SettleDelay: %d",
		sourceAddress, destinationAddress, amountStr, settleDelay)

	// Return mock result for now
	result := &xrpl.TransactionResult{
		TransactionID: "pc_" + fmt.Sprintf("%d", time.Now().Unix()),
		ResultCode:    "tesSUCCESS",
		ResultMessage: "Payment channel created successfully",
	}

	return result, nil
}

// CreateTrustLine creates a trust line for token operations
func (s *EnhancedXRPLService) CreateTrustLine(accountAddress, currency, issuer string, limit string) (*xrpl.TransactionResult, error) {
	if !s.initialized {
		return nil, fmt.Errorf("XRPL service not initialized")
	}

	log.Printf("Creating trust line: Account: %s, Currency: %s, Issuer: %s, Limit: %s",
		accountAddress, currency, issuer, limit)

	// Return mock result for now
	result := &xrpl.TransactionResult{
		TransactionID: "tl_" + fmt.Sprintf("%d", time.Now().Unix()),
		ResultCode:    "tesSUCCESS",
		ResultMessage: "Trust line created successfully",
	}

	return result, nil
}

// CreatePaymentTransaction creates a payment transaction for XRPL
func (s *EnhancedXRPLService) CreatePaymentTransaction(fromAddress, toAddress, amount, currency, memo string, sourceTag uint32) (*xrpl.PaymentTransaction, error) {
	if !s.initialized {
		return nil, fmt.Errorf("XRPL service not initialized")
	}

	// Get current sequence number for the source account
	accountInfo, err := s.client.GetAccountInfo(fromAddress)
	if err != nil {
		return nil, fmt.Errorf("failed to get account info: %w", err)
	}

	// Parse account info to get sequence
	var sequence uint32
	if accountMap, ok := accountInfo.(map[string]interface{}); ok {
		if accountData, exists := accountMap["account_data"]; exists {
			if accountDataMap, ok := accountData.(map[string]interface{}); ok {
				if seq, exists := accountDataMap["Sequence"]; exists {
					if seqFloat, ok := seq.(float64); ok {
						sequence = uint32(seqFloat)
					}
				}
			}
		}
	}

	// Get current ledger index for LastLedgerSequence
	// For now, use a default value since getCurrentLedgerIndex is unexported
	ledgerIndex := uint32(10000000) // Default testnet ledger index

	// Create payment transaction
	payment := &xrpl.PaymentTransaction{
		Account:            fromAddress,
		Destination:        toAddress,
		Amount:             s.client.FormatAmount(parseFloat(amount), currency),
		Fee:                "12", // Default fee in drops
		Sequence:           sequence,
		LastLedgerSequence: ledgerIndex + 20, // 20 ledgers ahead
		TransactionType:    "Payment",
		Flags:              0x00080000, // tfFullyCanonicalSig
	}

	return payment, nil
}

// SignPaymentTransaction signs a payment transaction with the provided private key
func (s *EnhancedXRPLService) SignPaymentTransaction(transaction *xrpl.PaymentTransaction, privateKeyHex string, keyType string) (string, error) {
	if !s.initialized {
		return "", fmt.Errorf("XRPL service not initialized")
	}

	// For now, return a mock transaction blob
	// In a real implementation, this would use the enhanced client's signing method
	return "mock_transaction_blob_" + fmt.Sprintf("%d", time.Now().Unix()), nil
}

// SubmitPaymentTransaction submits a signed payment transaction to the XRPL network
func (s *EnhancedXRPLService) SubmitPaymentTransaction(txBlob string) (*xrpl.TransactionResult, error) {
	if !s.initialized {
		return nil, fmt.Errorf("XRPL service not initialized")
	}

	// For now, return a mock result since the enhanced client doesn't have submit method
	// In a real implementation, this would submit to XRPL
	return &xrpl.TransactionResult{
		TransactionID: "mock_transaction_id",
		LedgerIndex:   0,
		Validated:     false,
		ResultCode:    "tesSUCCESS",
		ResultMessage: "Transaction submitted successfully (mock)",
	}, nil
}

// MonitorPaymentTransaction monitors the status of a submitted payment transaction
func (s *EnhancedXRPLService) MonitorPaymentTransaction(transactionID string, maxRetries int, retryInterval time.Duration) (*xrpl.TransactionStatus, error) {
	if !s.initialized {
		return nil, fmt.Errorf("XRPL service not initialized")
	}

	// For now, return a mock status
	// In a real implementation, this would monitor the transaction
	return &xrpl.TransactionStatus{
		TransactionID: transactionID,
		Status:        "validated",
		SubmitTime:    time.Now(),
		LastChecked:   time.Now(),
		RetryCount:    0,
		LedgerIndex:   12345,
		Validated:     true,
		ResultCode:    "tesSUCCESS",
		ResultMessage: "Transaction validated successfully",
	}, nil
}

// CompletePaymentTransactionWorkflow executes the complete Phase 1 workflow
func (s *EnhancedXRPLService) CompletePaymentTransactionWorkflow(fromAddress, toAddress, amount, currency, privateKeyHex, keyType string) (*xrpl.TransactionStatus, error) {
	if !s.initialized {
		return nil, fmt.Errorf("XRPL service not initialized")
	}

	log.Printf("Starting complete payment transaction workflow: %s -> %s, Amount: %s %s", fromAddress, toAddress, amount, currency)

	// Step 1: Create payment transaction
	payment, err := s.CreatePaymentTransaction(fromAddress, toAddress, amount, currency, "", 1)
	if err != nil {
		return nil, fmt.Errorf("failed to create payment transaction: %w", err)
	}

	// Step 2: Sign transaction
	txBlob, err := s.SignPaymentTransaction(payment, privateKeyHex, keyType)
	if err != nil {
		return nil, fmt.Errorf("failed to sign payment transaction: %w", err)
	}

	// Step 3: Submit transaction
	result, err := s.SubmitPaymentTransaction(txBlob)
	if err != nil {
		return nil, fmt.Errorf("failed to submit payment transaction: %w", err)
	}

	// Step 4: Monitor transaction
	status, err := s.MonitorPaymentTransaction(result.TransactionID, 2, 100*time.Millisecond)
	if err != nil {
		return nil, fmt.Errorf("failed to monitor payment transaction: %w", err)
	}

	return status, nil
}

// Helper function to parse float from string
func parseFloat(s string) float64 {
	if f, err := strconv.ParseFloat(s, 64); err == nil {
		return f
	}
	return 0.0
}

// Disconnect closes the XRPL service connections
func (s *EnhancedXRPLService) Disconnect() error {
	if s.client != nil {
		return s.client.Disconnect()
	}
	return nil
}

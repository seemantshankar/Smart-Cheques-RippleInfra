package mocks
import (
	"context"
	"time"
	"github.com/google/uuid"
	"github.com/stretchr/testify/mock"
	"github.com/smart-payment-infrastructure/internal/models"
	"github.com/smart-payment-infrastructure/pkg/messaging"
	"github.com/smart-payment-infrastructure/pkg/xrpl"
)
// AssetRepositoryInterface mock
type AssetRepositoryInterface struct {
	mock.Mock
}
func (m *AssetRepositoryInterface) GetAssetByCurrency(ctx context.Context, currency string) (*models.SupportedAsset, error) {
	args := m.Called(ctx, currency)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.SupportedAsset), args.Error(1)
}
func (m *AssetRepositoryInterface) CreateAsset(ctx context.Context, asset *models.SupportedAsset) error {
	args := m.Called(ctx, asset)
	return args.Error(0)
}
func (m *AssetRepositoryInterface) CreateAssetTransaction(ctx context.Context, transaction *models.AssetTransaction) error {
	args := m.Called(ctx, transaction)
	return args.Error(0)
}
func (m *AssetRepositoryInterface) UpdateAssetTransaction(ctx context.Context, transaction *models.AssetTransaction) error {
	args := m.Called(ctx, transaction)
	return args.Error(0)
}
func (m *AssetRepositoryInterface) GetAssetTransactionsByEnterprise(ctx context.Context, enterpriseID uuid.UUID, limit, offset int) ([]*models.AssetTransaction, error) {
	args := m.Called(ctx, enterpriseID, limit, offset)
	return args.Get(0).([]*models.AssetTransaction), args.Error(1)
}
// BalanceRepositoryInterface mock
type BalanceRepositoryInterface struct {
	mock.Mock
}
func (m *BalanceRepositoryInterface) GetBalance(ctx context.Context, enterpriseID uuid.UUID, currencyCode string) (*models.EnterpriseBalance, error) {
	args := m.Called(ctx, enterpriseID, currencyCode)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.EnterpriseBalance), args.Error(1)
}
func (m *BalanceRepositoryInterface) UpdateBalance(ctx context.Context, balance *models.EnterpriseBalance) error {
	args := m.Called(ctx, balance)
	return args.Error(0)
}
func (m *BalanceRepositoryInterface) GetEnterpriseBalances(ctx context.Context, enterpriseID uuid.UUID) ([]*models.EnterpriseBalance, error) {
	args := m.Called(ctx, enterpriseID)
	return args.Get(0).([]*models.EnterpriseBalance), args.Error(1)
}
func (m *BalanceRepositoryInterface) CreateEnterpriseBalance(ctx context.Context, balance *models.EnterpriseBalance) error {
	args := m.Called(ctx, balance)
	return args.Error(0)
}
// XRPLServiceInterface mock
type XRPLServiceInterface struct {
	mock.Mock
}
func (m *XRPLServiceInterface) CreateWallet() (*xrpl.WalletInfo, error) {
	args := m.Called()
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*xrpl.WalletInfo), args.Error(1)
}
func (m *XRPLServiceInterface) ValidateAddress(address string) bool {
	args := m.Called(address)
	return args.Bool(0)
}
func (m *XRPLServiceInterface) GetAccountInfo(address string) (interface{}, error) {
	args := m.Called(address)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0), args.Error(1)
}
func (m *XRPLServiceInterface) HealthCheck() error {
	args := m.Called()
	return args.Error(0)
}
// UserServiceInterface mock (referenced in withdrawal authorization service)
type UserServiceInterface struct {
	mock.Mock
}
func (m *UserServiceInterface) GetUser(ctx context.Context, userID uuid.UUID) (*models.User, error) {
	args := m.Called(ctx, userID)
	return args.Get(0).(*models.User), args.Error(1)
}
func (m *UserServiceInterface) GetEnterpriseUsers(ctx context.Context, enterpriseID uuid.UUID) ([]*models.User, error) {
	args := m.Called(ctx, enterpriseID)
	return args.Get(0).([]*models.User), args.Error(1)
}
func (m *UserServiceInterface) HasPermission(ctx context.Context, userID uuid.UUID, permission string) (bool, error) {
	args := m.Called(ctx, userID, permission)
	return args.Bool(0), args.Error(1)
}
// EventBus mock
type EventBus struct {
	mock.Mock
}
func (m *EventBus) PublishEvent(ctx context.Context, event *messaging.Event) error {
	args := m.Called(ctx, event)
	return args.Error(0)
}
func (m *EventBus) Subscribe(ctx context.Context, topic string, handler func(*messaging.Event) error) error {
	args := m.Called(ctx, topic, handler)
	return args.Error(0)
}
func (m *EventBus) Close() error {
	args := m.Called()
	return args.Error(0)
}
// TransactionRepositoryInterface mock
type TransactionRepositoryInterface struct {
	mock.Mock
}
// Transaction CRUD operations
func (m *TransactionRepositoryInterface) CreateTransaction(transaction *models.Transaction) error {
	args := m.Called(transaction)
	return args.Error(0)
}
func (m *TransactionRepositoryInterface) GetTransactionByID(id string) (*models.Transaction, error) {
	args := m.Called(id)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.Transaction), args.Error(1)
}
func (m *TransactionRepositoryInterface) UpdateTransaction(transaction *models.Transaction) error {
	args := m.Called(transaction)
	return args.Error(0)
}
func (m *TransactionRepositoryInterface) DeleteTransaction(id string) error {
	args := m.Called(id)
	return args.Error(0)
}
// Transaction queries
func (m *TransactionRepositoryInterface) GetTransactionsByStatus(status models.TransactionStatus, limit, offset int) ([]*models.Transaction, error) {
	args := m.Called(status, limit, offset)
	return args.Get(0).([]*models.Transaction), args.Error(1)
}
func (m *TransactionRepositoryInterface) GetTransactionsByBatchID(batchID string) ([]*models.Transaction, error) {
	args := m.Called(batchID)
	return args.Get(0).([]*models.Transaction), args.Error(1)
}
func (m *TransactionRepositoryInterface) GetTransactionsByEnterpriseID(enterpriseID string, limit, offset int) ([]*models.Transaction, error) {
	args := m.Called(enterpriseID, limit, offset)
	return args.Get(0).([]*models.Transaction), args.Error(1)
}
func (m *TransactionRepositoryInterface) GetTransactionsByUserID(userID string, limit, offset int) ([]*models.Transaction, error) {
	args := m.Called(userID, limit, offset)
	return args.Get(0).([]*models.Transaction), args.Error(1)
}
func (m *TransactionRepositoryInterface) GetTransactionsByType(txType models.TransactionType, limit, offset int) ([]*models.Transaction, error) {
	args := m.Called(txType, limit, offset)
	return args.Get(0).([]*models.Transaction), args.Error(1)
}
func (m *TransactionRepositoryInterface) GetPendingTransactions(limit int) ([]*models.Transaction, error) {
	args := m.Called(limit)
	return args.Get(0).([]*models.Transaction), args.Error(1)
}
func (m *TransactionRepositoryInterface) GetExpiredTransactions() ([]*models.Transaction, error) {
	args := m.Called()
	return args.Get(0).([]*models.Transaction), args.Error(1)
}
func (m *TransactionRepositoryInterface) GetRetriableTransactions() ([]*models.Transaction, error) {
	args := m.Called()
	return args.Get(0).([]*models.Transaction), args.Error(1)
}
// Batch operations
func (m *TransactionRepositoryInterface) CreateTransactionBatch(batch *models.TransactionBatch) error {
	args := m.Called(batch)
	return args.Error(0)
}
func (m *TransactionRepositoryInterface) GetTransactionBatchByID(id string) (*models.TransactionBatch, error) {
	args := m.Called(id)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.TransactionBatch), args.Error(1)
}
func (m *TransactionRepositoryInterface) UpdateTransactionBatch(batch *models.TransactionBatch) error {
	args := m.Called(batch)
	return args.Error(0)
}
func (m *TransactionRepositoryInterface) DeleteTransactionBatch(id string) error {
	args := m.Called(id)
	return args.Error(0)
}
func (m *TransactionRepositoryInterface) GetTransactionBatchesByStatus(status models.TransactionStatus, limit, offset int) ([]*models.TransactionBatch, error) {
	args := m.Called(status, limit, offset)
	return args.Get(0).([]*models.TransactionBatch), args.Error(1)
}
func (m *TransactionRepositoryInterface) GetPendingBatches(limit int) ([]*models.TransactionBatch, error) {
	args := m.Called(limit)
	return args.Get(0).([]*models.TransactionBatch), args.Error(1)
}
// Statistics and monitoring
func (m *TransactionRepositoryInterface) GetTransactionStats() (*models.TransactionStats, error) {
	args := m.Called()
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.TransactionStats), args.Error(1)
}
func (m *TransactionRepositoryInterface) GetTransactionStatsByDateRange(start, end time.Time) (*models.TransactionStats, error) {
	args := m.Called(start, end)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.TransactionStats), args.Error(1)
}
func (m *TransactionRepositoryInterface) GetTransactionCountByStatus() (map[models.TransactionStatus]int64, error) {
	args := m.Called()
	return args.Get(0).(map[models.TransactionStatus]int64), args.Error(1)
}
func (m *TransactionRepositoryInterface) GetAverageProcessingTime() (float64, error) {
	args := m.Called()
	return args.Get(0).(float64), args.Error(1)
}
// ContractRepositoryInterface mock
type ContractRepositoryInterface struct {
	mock.Mock
}
func (m *ContractRepositoryInterface) CreateContract(ctx context.Context, contract *models.Contract) error {
	args := m.Called(ctx, contract)
	return args.Error(0)
}
func (m *ContractRepositoryInterface) GetContractByID(ctx context.Context, id string) (*models.Contract, error) {
	args := m.Called(ctx, id)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.Contract), args.Error(1)
}
func (m *ContractRepositoryInterface) UpdateContract(ctx context.Context, contract *models.Contract) error {
	args := m.Called(ctx, contract)
	return args.Error(0)
}
func (m *ContractRepositoryInterface) DeleteContract(ctx context.Context, id string) error {
	args := m.Called(ctx, id)
	return args.Error(0)
}
func (m *ContractRepositoryInterface) GetContractsByStatus(ctx context.Context, status string, limit, offset int) ([]*models.Contract, error) {
	args := m.Called(ctx, status, limit, offset)
	return args.Get(0).([]*models.Contract), args.Error(1)
}
func (m *ContractRepositoryInterface) GetContractsByType(ctx context.Context, contractType string, limit, offset int) ([]*models.Contract, error) {
	args := m.Called(ctx, contractType, limit, offset)
	return args.Get(0).([]*models.Contract), args.Error(1)
}
func (m *ContractRepositoryInterface) GetContractsByParty(ctx context.Context, party string, limit, offset int) ([]*models.Contract, error) {
	args := m.Called(ctx, party, limit, offset)
	return args.Get(0).([]*models.Contract), args.Error(1)
}
// ContractMilestoneRepositoryInterface mock
type ContractMilestoneRepositoryInterface struct {
	mock.Mock
}
func (m *ContractMilestoneRepositoryInterface) CreateMilestone(ctx context.Context, milestone *models.ContractMilestone) error {
	args := m.Called(ctx, milestone)
	return args.Error(0)
}
func (m *ContractMilestoneRepositoryInterface) GetMilestoneByID(ctx context.Context, id string) (*models.ContractMilestone, error) {
	args := m.Called(ctx, id)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.ContractMilestone), args.Error(1)
}
func (m *ContractMilestoneRepositoryInterface) UpdateMilestone(ctx context.Context, milestone *models.ContractMilestone) error {
	args := m.Called(ctx, milestone)
	return args.Error(0)
}
func (m *ContractMilestoneRepositoryInterface) DeleteMilestone(ctx context.Context, id string) error {
	args := m.Called(ctx, id)
	return args.Error(0)
}
func (m *ContractMilestoneRepositoryInterface) GetMilestonesByContractID(ctx context.Context, contractID string) ([]*models.ContractMilestone, error) {
	args := m.Called(ctx, contractID)
	return args.Get(0).([]*models.ContractMilestone), args.Error(1)
}
// OracleRepositoryInterface mock
type OracleRepositoryInterface struct {
	mock.Mock
mock.Mock
}
